<?php
/**
 * Clustering of scripts
 *
 * This class is used for clustering scripts, trying to find script that cannot work without unsafe-inline
 *
 * @package No unsafe inline
 * @link    https://wordpress.org/plugins/no-unsafe-inline/
 * @since   1.0.0
 */

namespace NUNIL;

use Beager\Nilsimsa;
use Phpml\Clustering\DBSCAN;

/**
 * Class with methods used to cluster scripts
 *
 * @package no-unsafe-inline
 * @since   1.0.0
 */
class Nunil_Clustering {

	/**
	 * Convenience function to convert a hex digest into an array. Used by
	 * {compare_digests}
	 *
	 * @since 1.0.0
	 * @param string $digest The digest.
	 * @return array<int> The digest as an array of ints
	 */
	public static function convertHexDigestToArray( $digest ) {
		$result = array();

		for ( $i = 0; $i < 63; $i += 2 ) {
			$result[] = intval( hexdec( substr( $digest, $i, 2 ) ), $base = 10 );
		}

		return $result;
	}

	/**
	 * Function to get an array of obj from inline_scripts made of
	 * ID and nilsimsa hexDigest
	 *
	 * @since 1.0.0
	 *
	 * @param string $table The scripts table to be clustered: one of inline_scripts or event_handlers.
	 * @param string $segmentation_field Optional: the field used to segment clustering.
	 * @param string $segmentation_value Optional: the value of the field used to segment clustering.
	 * @param string $tagname     Optional: the tagname we want to cluster.
	 * @param string $clustername Optional: the clustername we want to cluster.
	 * @return array<\stdClass> of obj
	 */
	private static function get_nilsimsa_hashes( $table, $segmentation_field = null, $segmentation_value = null, $tagname = null, $clustername = null ) {
		global $wpdb;

		$where = '';

		$limit = 100000;

		$args = array();

		if ( func_num_args() > 0 ) {

			if ( $segmentation_field ) {
				$where  = $where . " $segmentation_field = %s AND";
				$args[] = $segmentation_value;
			}

			if ( $tagname ) {
				$where  = $where . ' tagname = %s AND';
				$args[] = $tagname;
			}

			if ( $clustername ) {
				$where  = $where . ' clustername = %s AND';
				$args[] = $clustername;
			}
		}

		if ( '' !== $where ) {
			$where = substr( $where, 0, strlen( $where ) - 4 );
			$where = 'WHERE ' . $where;
		}
		$args[] = $limit;

		$hashes = $wpdb->get_results(
			$wpdb->prepare(
				"SELECT ID, nilsimsa FROM $table $where LIMIT %d",
				$args
			),
			'OBJECT'
		);

		return $hashes;
	}

	/**
	 * Performs DBSCAN and return an array of clustered arrays
	 *
	 * @since 1.0.0
	 *
	 * @param array<\stdClass> $obj_hashes The array of obj generated by $wpdb->get_results.
	 * @param string           $table The scripts table to be clustered: one of inline_scripts or event_handlers (prefixed).
	 * @return array<array<array<int>>> Array of cluster made of arrays
	 */
	private static function make_db_scan( $obj_hashes, $table ) {

		$samples = array();

		$gls = new Nunil_Global_Settings();
		// building array of samples.
		foreach ( $obj_hashes as $hash ) {
			$nilsimsa_array = self::convertHexDigestToArray( $hash->nilsimsa );
			$samples[]      = $nilsimsa_array;
		}
		switch ( $table ) {
			case 'inline_scripts':
				$dbscan = new DBSCAN( $gls->dbscan_epsilon_inl, $gls->dbscan_minsamples_inl, new Nunil_Hamming_Distance() );
				break;
			case 'event_handlers':
				$dbscan = new DBSCAN( $gls->dbscan_epsilon_evh, $gls->dbscan_minsamples_evh, new Nunil_Hamming_Distance() );
				break;

			default:
				$dbscan = new DBSCAN( $gls->dbscan_epsilon_inl, $gls->dbscan_minsamples_inl, new Nunil_Hamming_Distance() );
				break;
		}

		$results = $dbscan->cluster( $samples );

		return $results;
	}

	/**
	 * Convert array to HexDigest, inverting convertHexDigestToArray
	 *
	 * @since 1.0.0
	 * @param array<int> $array The digest as an array of int.
	 * @return string The digest as an hexString
	 */
	public static function convertArraytoHexDigest( $array ) {
		$hexDigest = '';
		$l         = count( $array );
		for ( $i = 0; $i < $l; ++$i ) {
			$hexDigest = $hexDigest . str_pad( dechex( $array[ $i ] ), 2, '0', STR_PAD_LEFT );
		}
		return $hexDigest;
	}

	/**
	 * Returns a get_results OBJECT of [ID] [nilsimsa] [calculated_cluster]
	 * Puts the cluster value in database.
	 *
	 * @since 1.0.0
	 *
	 * @param string                   $table The scripts table to be clustered: one of inline_scripts or event_handlers (prefixed).
	 * @param array<\stdClass>         $obj_collection the get-results array of obj made of [ID] [nilsimsa hexDigest].
	 * @param array<array<array<int>>> $dbscan_results An array of clustered arrays returned by make_db_scan().
	 *
	 * @return array<\stdClass>    $obj_collection
	 */
	private static function cluster_digests( $table, $obj_collection, $dbscan_results ) {
		global $wpdb;

		$dbscan_array = array();

		foreach ( $dbscan_results as $cluster_key => $cluster ) {

			// using ClusterNames as Cl_000000001.
			$cluster_name = 'Cl_' . str_pad( strval( random_int( 1, 999999999 ) ), 9, '0', STR_PAD_LEFT );

			foreach ( $cluster as $arrayDigest ) {

				$hexDigest = self::convertArraytoHexDigest( $arrayDigest );

				$dbscan_array[] = array(
					'hexDigest'    => $hexDigest,
					'cluster_name' => $cluster_name,
				);
			}
		}

		foreach ( $obj_collection as &$element ) {

			$dbscan_key = array_search( $element->nilsimsa, array_column( $dbscan_array, 'hexDigest' ), true );

			$element = (array) $element;
			if ( $dbscan_key ) {
				$element['clustername'] = $dbscan_array[ $dbscan_key ]['cluster_name'];

			} else {
				$element['clustername'] = 'Unclustered';
			}
			$element = (object) $element;

			// Update table in DB.
			$data  = array(
				'clustername' => $element->clustername,
			);
			$where = array(
				'ID' => $element->ID,
			);
			$wpdb->update( $table, $data, $where );

		}

		/* If one of the elements are whitelisted, we whitelist all the cluster. */
		$clusters = $wpdb->get_results( "SELECT DISTINCT `clustername` FROM $table WHERE `clustername` <> 'Unclustered'" );
		foreach ( $clusters as $cluster ) {
			$wl = $wpdb->get_var( "SELECT MAX(`whitelist`) from $table WHERE `clustername` = '" . $cluster->clustername . "'" );

			$data  = array(
				'whitelist' => intval( $wl ),
			);
			$where = array(
				'clustername' => $cluster->clustername,
			);
			$wpdb->update( $table, $data, $where );
		}
		return $obj_collection;
	}

	/**
	 * Performs clustering by db scan
	 *
	 * @since 1.0.0
	 * @access public
	 * @return array{type: string, report:string} A report of performed operarions.
	 */
	public static function cluster_by_dbscan() {
		global $wpdb;

		$gls = new Nunil_Global_Settings();

		set_time_limit( $gls->clustering_time_limit );

		$start_time = microtime( true );

		$result_string = '<br><b> --- ' . esc_html__( 'CLUSTERING DATABASE', 'no-unsafe-inline' ) . ' --- </b><br>';

		$result_string = $result_string . esc_html__( 'Start time: ', 'no-unsafe-inline' ) . $start_time . '<br>';

		$scripts_tables = array(
			array(
				'table'              => 'inline_scripts',
				'segmentation_field' => 'directive',
			),
			array(
				'table'              => 'event_handlers',
				'segmentation_field' => 'event_attribute',
			),
		);

		foreach ( $scripts_tables as $tbl ) {
			
			$result_string = $result_string . '<br>' . sprintf( esc_html__( 'Clustering %s', 'no-unsafe-inline' ), '<b>' . $tbl['table'] . '</b>' ) . '<br>';

			$table = NO_UNSAFE_INLINE_TABLE_PREFIX . $tbl['table'];

			$seg_fields = $wpdb->get_results( 'SELECT DISTINCT `' . $tbl['segmentation_field'] . "` FROM $table", 'ARRAY_A' );

			foreach ( $seg_fields as $segment ) {
				$sql = "SELECT DISTINCT `tagname` FROM $table WHERE `" . $tbl['segmentation_field'] . "` = '" . $segment[ $tbl['segmentation_field'] ] . "'";

				$tagnames = $wpdb->get_results( "SELECT DISTINCT `tagname` FROM $table WHERE `" . $tbl['segmentation_field'] . "` = '" . $segment[ $tbl['segmentation_field'] ] . "'", 'ARRAY_A' );

				foreach ( $tagnames as $tagname ) {
					$obj_collection = self::get_nilsimsa_hashes( $table, $tbl['segmentation_field'], $segment[ $tbl['segmentation_field'] ], $tagname['tagname'], null );

					$result_string    = $result_string . '<br><b>' . $segment[ $tbl['segmentation_field'] ] . '</b> - <b><i>' . $tagname['tagname'] . '</i></b><br>';
					$result_string    = $result_string . esc_html__( 'Processed hashes: ', 'no-unsafe-inline' ) . count( $obj_collection ) . '<br>';
					$dbscan_results   = self::make_db_scan( $obj_collection, $tbl['table'] );
					$result_string    = $result_string . esc_html__( 'Clusters built: ', 'no-unsafe-inline' ) . strval( count( $dbscan_results ) ) . '<br>';
					$clustered_digest = self::cluster_digests( $table, $obj_collection, $dbscan_results );
					$result_string    = $result_string . ' ------- $$$ ------- <br>';
				}
			}
			$result_string = $result_string . 'End clustering <b>' . $tbl['table'] . '</b><br>';
		}
		$end_time = microtime( true );

		$result_string = $result_string . esc_html__( 'End time: ', 'no-unsafe-inline' ) . $end_time . '<br>';

		$execution_time = ( $end_time - $start_time );

		$result_string = $result_string . esc_html__( 'Execution time of script (sec): ', 'no-unsafe-inline' ) . $execution_time . '<br>';

		$result['type']   = 'success';
		$result['report'] = $result_string;

		// Destroy cache, after reclustering.
		$cache_group = 'no-unsafe-inline';
		$cache_key   = 'inline_rows';
		wp_cache_delete( $cache_key, $cache_group );
		$cache_key = 'events_rows';
		wp_cache_delete( $cache_key, $cache_group );

		return $result;
	}
}
