<?php
/**
 * Clustering of scripts
 *
 * This class is used for clustering scripts, trying to find script that cannot work without unsafe-inline
 *
 * @package No_unsafe-inline
 * @link    https://wordpress.org/plugins/no-unsafe-inline/
 * @since   1.0.0
 */

namespace NUNIL;

use Beager\Nilsimsa;
use Phpml\Clustering\DBSCAN;
use NUNIL\Nunil_Lib_Db as DB;
use NUNIL\Nunil_Lib_Log as Log;

/**
 * Class with methods used to cluster scripts
 *
 * @package No_unsafe-inline
 * @since   1.0.0
 */
class Nunil_Clustering {

	/**
	 * Convenience function to convert a hex digest into an array. Used by
	 * {compare_digests}
	 *
	 * @since 1.0.0
	 * @param string $digest The digest.
	 * @return array<int> The digest as an array of ints
	 */
	public static function convertHexDigestToArray( $digest ) {
		$result = array();

		for ( $i = 0; $i < 63; $i += 2 ) {
			$result[] = intval( hexdec( substr( $digest, $i, 2 ) ), $base = 10 );
		}

		return $result;
	}

	/**
	 * Performs DBSCAN and return an array of clustered arrays
	 *
	 * @since 1.0.0
	 *
	 * @param array<\stdClass> $obj_hashes The array of obj generated by $wpdb->get_results.
	 * @param string           $table The scripts table to be clustered: one of inline_scripts or event_handlers (prefixed).
	 * @return array<array<array<int>>> Array of cluster made of arrays
	 */
	private static function make_db_scan( $obj_hashes, $table ) {
		$samples = array();

		$gls = new Nunil_Global_Settings();
		// building array of samples.
		foreach ( $obj_hashes as $hash ) {
			$nilsimsa_array = self::convertHexDigestToArray( $hash->nilsimsa );
			$samples[]      = $nilsimsa_array;
		}
		switch ( $table ) {
			case 'inline_scripts':
				$dbscan = new DBSCAN( $gls->dbscan_epsilon_inl, $gls->dbscan_minsamples_inl, new Nunil_Hamming_Distance() );
				break;
			case 'event_handlers':
				$dbscan = new DBSCAN( $gls->dbscan_epsilon_evh, $gls->dbscan_minsamples_evh, new Nunil_Hamming_Distance() );
				break;

			default:
				$dbscan = new DBSCAN( $gls->dbscan_epsilon_inl, $gls->dbscan_minsamples_inl, new Nunil_Hamming_Distance() );
				break;
		}

		$results = $dbscan->cluster( $samples );

		return $results;
	}

	/**
	 * Convert array to HexDigest, inverting convertHexDigestToArray
	 *
	 * @since 1.0.0
	 * @param array<int> $array The digest as an array of int.
	 * @return string The digest as an hexString
	 */
	public static function convertArraytoHexDigest( $array ) {
		$hexDigest = '';
		$l         = count( $array );
		for ( $i = 0; $i < $l; ++$i ) {
			$hexDigest = $hexDigest . str_pad( dechex( $array[ $i ] ), 2, '0', STR_PAD_LEFT );
		}
		return $hexDigest;
	}

	/**
	 * Returns a get_results OBJECT of [ID] [nilsimsa] [calculated_cluster]
	 * Puts the cluster value in database.
	 *
	 * @since 1.0.0
	 *
	 * @param string                   $table The scripts table to be clustered: one of inline_scripts or event_handlers.
	 * @param array<\stdClass>         $obj_collection the get-results array of obj made of [ID] [nilsimsa hexDigest].
	 * @param array<array<array<int>>> $dbscan_results An array of clustered arrays returned by make_db_scan().
	 *
	 * @return array<\stdClass>    $obj_collection
	 */
	private static function cluster_digests( $table, $obj_collection, $dbscan_results ) {
		$dbscan_array = array();

		foreach ( $dbscan_results as $cluster_key => $cluster ) {

			// using ClusterNames as Cl_000000001.
			$cluster_name = 'Cl_' . str_pad( strval( random_int( 1, 999999999 ) ), 9, '0', STR_PAD_LEFT );

			foreach ( $cluster as $arrayDigest ) {
				$hexDigest = self::convertArraytoHexDigest( $arrayDigest );

				$dbscan_array[] = array(
					'hexDigest'    => $hexDigest,
					'cluster_name' => $cluster_name,
				);
			}
		}

		foreach ( $obj_collection as &$element ) {
			$dbscan_key = array_search( $element->nilsimsa, array_column( $dbscan_array, 'hexDigest' ), true );

			$element = (array) $element;
			if ( $dbscan_key ) {
				$element['clustername'] = $dbscan_array[ $dbscan_key ]['cluster_name'];
			} else {
				$element['clustername'] = 'Unclustered';
			}
			$element = (object) $element;

			// Update table in DB.
			$data  = array(
				'clustername' => $element->clustername,
			);
			$where = array(
				'ID' => $element->ID,
			);

			DB::update_cluster( $table, $data, $where );
		}

		// If one of the elements is whitelisted, we whitelist all the cluster.
		$clusters = DB::get_clusters_in_table( $table );
		foreach ( $clusters as $cluster ) {
			$wl = DB::get_max_wl_in_cluster( $table, $cluster->clustername );

			$data  = array(
				'whitelist' => intval( $wl ),
			);
			$where = array(
				'clustername' => $cluster->clustername,
			);
			DB::update_cluster( $table, $data, $where );
		}
		return $obj_collection;
	}

	/**
	 * Performs clustering by db scan
	 *
	 * @since 1.0.0
	 * @access public
	 * @return array{type: string, report:string} A report of performed operarions.
	 */
	public static function cluster_by_dbscan() {
		$gls = new Nunil_Global_Settings();

		set_time_limit( $gls->clustering_time_limit );

		$start_time = microtime( true );

		$result_string = '<br><b> --- ' . esc_html__( 'CLUSTERING DATABASE', 'no-unsafe-inline' ) . ' --- </b><br>';

		$result_string = $result_string . esc_html__( 'Start time: ', 'no-unsafe-inline' ) . $start_time . '<br>';

		$scripts_tables = array(
			array(
				'table'              => 'inline_scripts',
				'segmentation_field' => 'directive',
			),
			array(
				'table'              => 'event_handlers',
				'segmentation_field' => 'event_attribute',
			),
		);

		foreach ( $scripts_tables as $tbl ) {
			// translators:: %s is the table internal name.
			$result_string = $result_string . '<br>' . sprintf( esc_html__( 'Clustering %s', 'no-unsafe-inline' ), '<b>' . $tbl['table'] . '</b>' ) . '<br>';

			$table = $tbl['table'];

			$seg_fields = DB::get_segmentation_values( $tbl['segmentation_field'], $tbl['table'] );

			foreach ( $seg_fields as $segment ) {
				$tagnames = DB::get_tagnames( $tbl['segmentation_field'], $segment[ $tbl['segmentation_field'] ], $table );

				foreach ( $tagnames as $tagname ) {
					$obj_collection = DB::get_nilsimsa_hashes( $table, $tbl['segmentation_field'], $segment[ $tbl['segmentation_field'] ], $tagname['tagname'], null );

					$result_string    = $result_string . '<br><b>' . $segment[ $tbl['segmentation_field'] ] . '</b> - <b><i>' . $tagname['tagname'] . '</i></b><br>';
					$result_string    = $result_string . esc_html__( 'Processed hashes: ', 'no-unsafe-inline' ) . count( $obj_collection ) . '<br>';
					$dbscan_results   = self::make_db_scan( $obj_collection, $tbl['table'] );
					$result_string    = $result_string . esc_html__( 'Clusters built: ', 'no-unsafe-inline' ) . strval( count( $dbscan_results ) ) . '<br>';
					$clustered_digest = self::cluster_digests( $table, $obj_collection, $dbscan_results );
					$result_string    = $result_string . ' ------- $$$ ------- <br>';
				}
			}
			$result_string = $result_string . 'End clustering <b>' . $tbl['table'] . '</b><br>';
			Log::info( 'Performed clustering on ' . $tbl['table'] );
		}
		$end_time = microtime( true );

		$result_string = $result_string . esc_html__( 'End time: ', 'no-unsafe-inline' ) . $end_time . '<br>';

		$execution_time = ( $end_time - $start_time );

		$result_string = $result_string . esc_html__( 'Execution time of script (sec): ', 'no-unsafe-inline' ) . $execution_time . '<br>';

		$result['type']   = 'success';
		$result['report'] = $result_string;

		// Destroy cache, after reclustering.
		$cache_group = 'no-unsafe-inline';
		$cache_key   = 'inline_rows';
		wp_cache_delete( $cache_key, $cache_group );
		$cache_key = 'events_rows';
		wp_cache_delete( $cache_key, $cache_group );

		return $result;
	}
}
